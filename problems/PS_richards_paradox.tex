\documentclass[problem]{mcs}

\newcommand{\asciibet}{\text{ASCII}}
\newcommand{\asciistr}{\strings{\asciibet}}
\newcommand{\numstr}{\text{ASCII\_ NUM}}

\begin{pcomments}
  \pcomment{PS_infinite_sets_and_number_theory}
  \pcomment{draft by Stephan Boyers NEEDS WORK: confuses
    ill-definedness with uncountability--ARM 9/24/13}
\end{pcomments}

\pkeywords{
  infinite_sets
  number_theory
  countability
  uncountability
  diagonal_argument
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
 Ben Bitdiddle is building an online system to process orders for a
 restaurant.  Ben's brilliant idea is to have customers enter their
 orders online ahead of time so their food is ready when they arrive.
 Ben would like his online system to validate user input so that
 customers are immediately aware of any problems with their orders.
 Ben wants to make his system as user-friendly as possible.  In
 addition to specifying the items they want to order, customers should
 be able to input how many of each item they want---in plain English!
 For example, a customer should be able to order ``five factorial''
 french fries and ``positive square root of four'' hamburgers.
 However, a customer should not be able to order ``George Washington''
 slices of pizza (because ``George Washington'' does not describe a
 quantity).  Ben is faced with a challenge---how can a computer
 program determine whether an English phrase describes a number?

$\asciibet$ is a 256-character alphabet that is often used in computer
 software.  Let $\asciistr$ be the set of (finite) strings of
 $\asciibet$ characters, as described in Section~\bref{halting_sec} of
 the textbook.  Let $\numstr$ be the subset of $\asciistr$ which
 contains all finite English descriptions of nonnegative real numbers
 (not necessarily integers), and nothing else.

\bparts

\ppart\label{enumerate_numstr}
Propose a bijection between $\naturals$ and $\numstr$.

\begin{solution}
We can enumerate the strings in $\numstr$ by sorting them first by
length and then alphabetically.
\end{solution}

\ppart\label{diagonalization}
Consider the set $S$ of numbers identified by the strings in $\numstr$.
Describe a number which is not in $S$.

\begin{solution}
We use diagonalization.  Order the numbers in $S$ according to the
bijection from part~\eqref{enumerate_numstr}.  Construct a new number
$q$ according to the following: the integer part of $q$ is $1$, and
the $n^{\text{th}}$ digit in the decimal part of $q$ is $2$ if the
corresponding digit in the $n^{\text{th}}$ member of $S$ is not $2$,
and $1$ otherwise.  $q$ differs from every number in $S$ at some
digit, so $q \notin S$.
\end{solution}

\ppart\label{no_algorithm_for_numstr}
Is $\numstr$ a valid set?  Why?

\begin{solution}
The solution to part~\eqref{diagonalization} is an English description
of a number, so it must be in $\numstr$.  That number $q$ must therefore
be in $S$, but we have just shown otherwise---a contradiction.  So our
assumption that $\numstr$ is a valid set is false.
\end{solution}

\ppart\label{ben_restaurant_failure}

Explain why Ben cannot possibly write his algorithm.

\begin{solution}
If there was an algorithm for deciding whether an English string is a description of a number, we could construct a number $q$ which is not described by any string that the algorithm accepts using the technique in part~\eqref{diagonalization}.  But we have an English description for this number!  The algorithm must accept this description---a contradiction.  We conclude that Ben's algorithm must not exist.
\end{solution}

\eparts
\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem ends here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\endinput
