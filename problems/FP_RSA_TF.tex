\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{FP_RSA_TF}
  \pcomment{CH, spring '14}
\end{pcomments}

\pkeywords{
  RSA
  public key
  private key
  Euler's theorem
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}

Indicate whether the following statements are \textbf{true} or
\textbf{false} by circling \textbf{T} or \textbf{F}. Provide a brief
argument justifying your choice for each statement.

\bparts

\ppart If $n$ and $a$ are relatively prime, then $a^{\phi(n)} \equiv 1 \pmod{n}$.
\inhandout{\hfill \textbf{T} \qquad \textbf{F}}
\begin{solution}
\textbf{True.} This is the statement of Euler's Theorem.
\end{solution}

\examspace[0.6in]

\ppart If $n$ is a product of two distinct primes, then $\phi(n)$ is
odd. 
\inhandout{\hfill \textbf{T} \qquad \textbf{F}}
\begin{solution}
\textbf{False}. Let $n = pq$. Without loss of generality, let $2 \leq
p < q$. Then, we know that $\phi(n) = \phi(p)\phi(q) =
(p-1)(q-1)$. Since $q$ is odd, $q-1$ is even and hence $\phi(n)$ is even.
\end{solution}

\examspace[0.6in]

\ppart Suppose $a, b, c, d$ are any four positive integers. Then 
\[
[ac \equiv bc \pmod{d}] \QIMPLIES [a \equiv \b \pmod{d}] . 
\]
\inhandout{\hfill \textbf{T} \qquad \textbf{F}}
\begin{solution}
  \textbf{False}. To cancel $c$, we require that $c$ is relatively
  prime to $d$. A counter-example is $a=1, b=2, d=3$, and $c=6$. 
\end{solution}

\examspace[0.6in]

\ppart In the RSA Cryptosystem, if $n=pq$ then the private key $d$ and the public key
$(e,n)$ satisfy
\[
d \cdot e \equiv 1 \pmod{pq} .
\] 
\inhandout{\hfill \textbf{T} \qquad \textbf{F}}
\begin{solution}
  \textbf{False}. The values of $d$ and $e$ are chosen to satisfy:
\[
d \cdot e \equiv 1 \pmod{(p-1)(q-1)} .
\]
\end{solution}

\examspace[0.6in]

\ppart An efficient algorithm for \textsc{Factoring} would render RSA unsecure. 
\inhandout{\hfill \textbf{T} \qquad \textbf{F}}
\begin{solution}
 \textbf{True}. The given algorithm would read $(n, d)$ from the
 public key, efficiently calculate the prime  factors $p$ and $q$ of $n$, and
 compute the inverse of $d$ modulo $(p-1)(q-1)$ to get an $e$ that can decrypt any message.
\end{solution}

\eparts

\end{problem}

\endinput
