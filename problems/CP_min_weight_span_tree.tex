\documentclass[problem]{mcs}

\begin{pcomments}
\pcomment{CP_min_weight_span_tree}
\pcomment{from F07.rec7t, S06.cp5f, S04.cp5w}
\end{pcomments}

\pkeywords{
spanning_tree
weighted
tree
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
A \emph{weighted graph} is a graph with a function that assigns a
nonnegative real number to each edge.  The real number assigned to an edge
is called its \emph{weight}.  In this problem, we'll stick to
\emph{finite} graphs, so we can define the weight of any finite subgraph
to be the sum of the weights of its edges.

A \emph{minimum weight spanning tree} of a connected, weighted graph is a
spanning tree with the smallest weight of any spanning tree of the graph.

\begin{editingnotes}
An example would be nice.
\end{editingnotes}

\bparts

\ppart Show that every minimum weight spanning tree must contain at least
one edge that has the smallest edge weight.

\begin{solution}
Suppose that an edge $e$ with smallest weight is not included in
some minimal spanning tree; in other words, suppose that the minimum
spanning tree $T$ contains only edges with weights larger than that of
$e$.  If we add $e$ to $T$, (thereby completing the unique path
that already exists between the endpoints of $e$) then we will obtain a
graph with this one cycle that includes $e$.  We can then delete
some other edge in the cycle, without disconnecting any of the
vertices in that cycle.  This results in a spanning tree with weight
strictly less than that of $T$ (since all the other edges have larger
weight than $e$ has), contradicting the minimality of $T$.  We conclude
that an edge with smallest weight must be included in $T$.
\end{solution}

\ppart Use the result of the previous part to describe a simple procedure
for contructing a minimum weight spanning tree.  You may assume for
simplicity that all edge weights are distinct.

\begin{solution}
Keep picking a smallest weight edge that does not create a cycle
of picked edges---a classic ``greedy'' algorithm.
\end{solution}

\eparts

\end{problem}

\endinput
