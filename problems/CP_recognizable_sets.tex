\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{CP_recognizable_sets}
  \pcomment{from: S06.cp2f, F09(?)}
  \pcomment{revised by ARM 9/20/09 and more 3/16/10}
  \pcomment{needs handy copy of Russell paradox or Theorem~\bref{powbig}}
\end{pcomments}

\pkeywords{
  diagonal argument
  Russell paradox
  recognizable
  halting problem
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
Let's refer to a programming procedure (written in your favorite
programming language---C++, or Java, or Python, \dots) as a \term{string
  procedure} when it is applicable to data of type \texttt{string} and
only returns values of type \texttt{boolean}.  When a string procedure,
$P$, applied to a \texttt{string}, $s$, returns \True, we'll say that $P$
\term{recognizes} $s$.  If $\mathcal{R}$ is the set of strings that $P$
recognizes, we'll call $P$ a \term{recognizer} for $\mathcal{R}$.

\bparts

\ppart\label{odd_numeral} Describe how a recognizer would work for the
set of strings containing only lower case Roman
letters---\texttt{a,b,\dots,z}---such that each letter occurs twice in
a row.  For example, \texttt{aaccaabbzz}, is such a string, but
\texttt{abb}, \texttt{00bb}, \texttt{AAbb}, and \texttt{a} are not.
(Even better, actually write a recognizer procedure in your favorite
programming language).

\begin{solution}
  All the standard programming languages have built-in operations for
  scanning the characters in a string.  So simply write a procedure
  that checks an input string left to right, verifying that successive
  pairs of characters in the string are duplicated, lowercase roman characters.

\textbf{ACTUAL PROGRAM TBA}

\end{solution}

\eparts

A set of \texttt{string}s is called \emph{recognizable} if
there is a recognizer procedure for it.

When you actually program a procedure, you have to type the program text
into a computer system.  This means that every procedure is described by
some \texttt{string} of typed characters.  If a \texttt{string}, $s$, is
actually the typed description of some string procedure, let's refer to
that procedure as $P_s$.  You can think of $P_s$ as the result of
compiling $s$.\footnote{The string, $s$, and the procedure, $P_s$, have to
  be distinguished to avoid a type error: you can't apply a string to
  string.  For example, let $s$ be the string that you wrote as your
  program to answer part~\eqref{odd_numeral}.  Applying $s$ to a string
  argument, say \texttt{oorrmm}, should throw a type exception; what you
  need to do is apply the procedure $P_s$ to \texttt{oorrmm}.  This should
  result in a returned value \True, since \texttt{oorrmm} consists of
  three pairs of lowercase roman letters}

In fact, it will be helpful to associate every string, $s$, with a
procedure, $P_s$; we can do this by defining $P_s$ to be some fixed string
procedure---it doesn't matter which one---whenever $s$ is not the typed
description of an actual procedure that can be applied to
\texttt{string}'s.  The result of this is that we have now defined a total
function, $f$, mapping every \texttt{string}, $s$, to the set, $f(s)$, of
\texttt{string}s recognized by $P_s$.  That is we have a total function,
\begin{equation}\label{f:s-to-Ps}
f: \mtt{string} \to \power(\mtt{string}).
\end{equation}

\bparts

\ppart
Explain why the actual range of $f$ is the set of all recognizable sets of
strings.

\begin{solution}
Since $f(s)$ is the set of strings recognized by $P_s$, everything in
$\range{f}$ is a recogizable set.  Conversely,  every recogizable set is
in $\range{f}$: if $\mathcal{R}$ is a recognizable
set, then by definition, there is a procedure, $P$, that recognizes $R$.  So
if $r$ is the input program from which $P$ was compiled, then
$\mathcal{R} = f(r)$.
\end{solution}

\eparts

This is exactly the set up we need to apply the reasoning behind Russell's
Paradox to define a set that is not in the range of $f$, that is, a set of
strings, $\mathcal{N}$, that is \emph{not} recognizable.

\bparts

\ppart\label{Ps-to-s}
Let
\[
\mathcal{N} \eqdef \set{s \in \mtt{string} \suchthat s \notin f(s)}.
\]

Prove that $\mathcal{N}$ is not recognizable.

\hint Similar to Russell's paradox or the proof of Theorem~\bref{powbig}.

\begin{staffnotes}
Refer students to the Russell paradox slide or the Text for Theorem~\bref{powbig}.
\end{staffnotes}

\begin{solution}
By definition of $\mathcal{N}$,
\begin{equation}\label{Ps}
s \in \mathcal{N} \qiff s \notin f(s).
\end{equation}
for every \texttt{string}, $s$.

Now assume to the contrary that $\mathcal{N}$ was recognizable by some
string procedure.  This procedure must have a string, $w$, that
describes it, so we have
\begin{align}
s \in \mathcal{N} & \qiff P_w \text{ applied to $s$ returns \True},\notag\\
                  & \qiff s \in f(w) \label{Pr} & \text{(by def.\ of $f$)}
\end{align}
for all \texttt{string}'s $s$.

Combining~\eqref{Ps} and ~\eqref{Pr}, we have that for every string, $s$,
\begin{equation}\label{PP}
s \notin f(s) \qiff s \in f(w),
\end{equation}
for all \texttt{string}'s $s$.

Now letting $s$ be $w$ in~\eqref{PP}, we reach the contradiction
\[
w \notin f(w) \qiff w \in f(w).
\]
This contradiction implies that the assumption that $\mathcal{N}$ was
recognizable must be false.

\end{solution}

\ppart Discuss what the conclusion of part~\eqref{Ps-to-s} implies about
the possibility of writing ``program analyzers'' that take programs
as inputs and analyze their behavior.

\begin{solution}
  Let's call a programming procedure ``self-unconscious'' if it does not
  return \True\ when applied to its own textual definition.

  Rephrased informally, the conclusion of part~\eqref{Ps-to-s} says that
  it is logically impossible to design a \emph{general} program analyzer,
  which takes as input the (textual definition) of an arbitrary program,
  and recognizes when the program is self-unconscious.  This implies that
  it is impossible to write a program which does the more general analysis
  of how an arbitrary procedure behaves when applied to some given
  arguments.

  BTW, it \emph{is} feasible to write a general procedure that
  recognizes when an arbitrary input procedure \emph{does} return a
  value when appiled to the string that describes it---that is, when
  the procedure is \emph{self-conscious}.  The general procedure
  appllied to input $s$ just simulates $P_s$ applied to $s$.  In other
  words, this general procedure just acts like a virtual machine
  simulator or ``interpreter'' for the programming language of its
  input programs.

  It's also important to recognize that there's no hope of getting around
  this by switching programming languages.  For example, by
  part~\eqref{Ps-to-s}, no C++ program can analyze arbitrary C++ programs,
  and no Java program can analyze Java programs, but you might wonder if a
  language like C++, which allows more intimate manipulation of computer
  memory than Java, might therefore allow a C++ program to analyze general
  Java programs.  But there is no loophole here: since it's possible to
  write a Java program that is a simulator/interpreter for C++ programs,
  if a C++ program could analyze Java programs, so could the Java program
  that simulated the C++ program, contradicting~\eqref{Ps-to-s}.

  It's a different story if we think about the \emph{practical}
  possibility of writing programming analyzers.  The fact that it's
  logically impossible to write analyzers for completely general programs
  does not mean that you can't do a very good job analyzing interesting
  programs that come up in practice.  In fact these ``interesting''
  programs are commonly \emph{intended} to be analyzable in order to
  confirm that they do what they're supposed to do.

  So it's not clear how much of a hurdle this theoretical limitation
  implies in practice.  What the theory does provide is some perspective
  on claims about general analysis methods for programs.  The theory tells
  us that people who make such claims either

\begin{itemize}
\item are exaggerating the power (if any) of their methods---say to get a
  grant or make a sale, or

\item are trying to keep things simple by not going into technical
  limitations they're aware of, or

\item perhaps most commonly, are so excited about some useful practical
    successes of their methods, that they haven't bothered to think about
    their limitations.
\end{itemize}

So from now on, if you hear people making claims about completely general
program analysis/verification/optimization methods, you'll know they can't
be telling the whole story.
\end{solution}

\eparts

\end{problem}

\endinput
