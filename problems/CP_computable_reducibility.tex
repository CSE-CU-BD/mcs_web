\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{CP_computable_reducibility}
  \pcomment{ARM 3/7/16}
\end{pcomments}

\pkeywords{
  sets
  set_theory
  diagonal_argument
  Russell_paradox
  recognizable
  halting_problem
}

%\asciibet}{\text{ASCII}}
%\asciistr}{\strings{\asciibet}}

%\newcommand{\strtyp}{\ensuremath{\textbf{string}}}

%\newcommand{\rcg}{\text{lang}} % \def\all0s{\textbf{all-0s}}
%\newcommand{\lsub}[1]{\ensuremath{L_{#1}}}
%\newcommand{\notself}{\text{\small{Not-self}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
As in the Section~\bref{halting_sec}, a \emph{string procedure} is
procedure that is applicable to strings over the \asciibet\ alphabet.
When the computation that results from applying a string procedure,
$P$, to a string $s \in \asciistr$ eventually halts, we say that $P$
\term{recognizes} $s$, and we define $\rcg{P}$ to be the set of
strings or \emph{language} recognized by $P$.

A procedure declaration is a text, $s \in \asciistr$, that conforms to
the grammatical rules for programs.  Such a declaration defines a
procedure $P_s$, which we can think of as the result of compiling $s$
to an executable.  If $s \in \asciistr$ is not a grammatically
well-formed procedure declaration, we define $P_s$ to be a procedure
that fails to halt when applied to any string, so $\rcg{P_S} \eqdef
\emptyset$.  Now every string defines a string procedure, and every
string procedure is $P_s$ for some $s \in \asciistr$.

An easy diagonal argument in The text showed that
\[
\nohalt \eqdef \set{s \in \asciistr \suchthat P_s\ \text{does not
    recognize}\ s} = \overline{\rcg{P_s}}
\]
is not recognizable.  But we can agree that it's pretty weird to apply
a procedure to its own declaration.  Are there any less contrived
languages that are not recognizable?  In this problem, we will show
that there are lots.  In fact, unrecognizable languages are hard to
avoid.

We'll find lots of unrecognizable languages by learning how to reduce
the membership problem in one language to the membership problem of
another language.

\begin{definition}
A procedure that takes string inputs and returns string outputs is
called a \emph{string I/O-procedure}.  The function $\phi: \asciistr
\to \asciistr$ where $\phi(s)$ is the output, if any, when the
procedure is applied to $s$, is called a \emph{partial computable
  function}.  An I/O-procedure that always returns an output---it
never runs forever or aborts no matter what string it is applied
to---defines a total function called a \emph{total computable
  function} $f:\asciistr \to \asciistr$.

If $L,M \subseteq \asciistr$ are languages, $L$ is defined to
\emph{reducible} to $M$,\footnote{There are many different notions of
  how one langauge can be reduced to another.  The particular one we 
  use is known in the literature as ``many-one'' reducibility.}
in symbols,
\[
L \preceq M
\]
iff there is a total computable procedure $f$ such that
\[
s \in L\ \QIFF\ f(s) \in M.
\]
for all $s \in \asciistr$.
\end{definition}
So if you want to know whether $s$ is a member of $L$, just transform
$s$ into $f(s)$ and figure out whether $f(s)$ is in $M$.

\bparts

\ppart Suppose $L \preceq M$ and $M$ is recognizable.  Explain why $L$ must be recognizable.

\hint Combine the recognizer for $M$ with the procedure for the total
computable function reducing $L$ to $M$.

\ppart Conclude that if $L \preceq M$ and $L$ is not recognizable, then neither is $M$.

\eparts

\medskip

Let $\mathcal{P}(L)$ be a property of languages $L$.  For example, $\mathcal{P}$
might be the properties like
\begin{align*}
\mathcal{P}_0(L) & \eqdef \emptystring \in L,\\
\mathcal{P}_1(L) & \eqdef L\ \text{is finite},\\
\mathcal{P}_2(L) & \eqdef L \subseteq \set{\text{strings of even length}},\\
\mathcal{P}_3(L) & \eqdef L  = \set{\texttt{AA, \$\#az, shortpasswordsareinsecureBut}}.
\end{align*}

Now suppose we are trying find a procedure analyzer that recognizes
when a string procedure applied to the emptystring will halt.  This
may not be an exciting property to check for, but it is certainly less
weird than recognizing when a declared procedure halts on its own
declaration.

\bparts

\ppart The problem of analyzing string procedures to see if they halt
on the emptystring can be formalized as asking whether a certain
language is recognizable.  This language consists of the strings $s \asciistr$ such that:
\begin{enumerate}[i]
\item $P_s \emptystring \in P_s$             %type-error
\item $P_s \subseteq \set{ \emptystring}}$          %type-error
\item $P_s \text{ recognizes } \emptystring}$ %OK
\item $\emptystring \in \rcg{P_s}}$           %OK
\item $P_s \text{halts when applied to the}\ \emptystring}$ %OK
\item $\mathcal{P}_0(\rcg{P_s})$              %OK
\item $\mathcal{P}_0(\set{\emptystring})$     %OK
\item $\mathcal{P}_0(\overline{\rcg{P_s}})}$  %probably OK
\item $\rcg{P_s} = \set{ \emptystring}}$      %NO
\item $\rcg{P_s} = \set{ \emptystring}}$      %NO
\end{enumerate}

More generally, for any language property $\mathcal{P}$, let
\[
L_{\mathcal{P}} \eqdef \set{s \in \asciistr \suchthat \mathcal{P}(\rcg{P_s})}
\]
Now analyzing string procedures to see if they halt on the emptystring
means recognizing the language $L_{\mathcal{P}_0}$.

Analyzing a string procedure to determine if it recognizes a language
with property.  This means we are asking whether the language
\[
L_{\mathcal{P}} \eqdef \set{s \in \asciistr \suchthat \mathcal{P}(\rcg{P_s})}
\]
is recognizable.

This means we are simply asking is the following
language recognizable:
\[
\set{s \in \asciistr \suchthat \emptystring \in \rcg{P_s}}.
\]



Now we are asking for a recognizer for the strings $s$ such that $P_s$
applied to $\emptystring$ halts.  This is the same as asking whether
$P_s$ recognizes $\emptystring$, which can further rephrased as
asking: is
\[
\set{s \in \asciistr \suchthat \mathcal{P_0}(\rcg{P_s})}
\]


Anyway, recognizing when a procedure applied to the
empty string halts means recognizing


That is, given the procedure declaration $s \asciistr$, does
$\rcg{P_s}$

 procedures  to find a procedure analyzer that recognizes
given any procedure declaration, whether the declared procedure halts
k  

That is, can we recognize


when a string procedure recognizes a language with property
$\mathcal{P}$.  This means we are asking whether the language
\[
L_{\mathcal{P}} \eqdef \set{s \in \asciistr \suchthat \mathcal{P}(\rcg{P_s})}
\]
is recognizable.



  We can rephrase
this question in the following simple way: is there a recognizer for
\[
\set{s \in \asciistr \suchthat P_s\ \text{does not halt when applied to the}\ \emptystring}\ ?
\]
A more concise way to phrase this would be: is the language
\[
s \in \asciistr \suchthat 

So we're asking
if we can find a recognizer for
\[


\begin{theorem}


\end{theorem}
\end{problem}

\endinput
