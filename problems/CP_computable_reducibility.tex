\documentclass[problem]{mcs}

\begin{pcomments}
  \pcomment{CP_computable_reducibility}
  \pcomment{ARM 3/7/16}
\end{pcomments}

\pkeywords{
  sets
  set_theory
  diagonal_argument
  Russell_paradox
  recognizable
  halting_problem
}

%\asciibet}{\text{ASCII}}
%\asciistr}{\strings{\asciibet}}

\newcommand{\strtyp}{\ensuremath{\textbf{string}}}

\newcommand{\rcg}{\text{lang}} % \def\all0s{\textbf{all-0s}}
\newcommand{\lsub}[1]{\ensuremath{L_{#1}}}
\newcommand{\notself}{\text{\small{Not-self}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem starts here
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
As in the Section~\bref{halting_sec}, we'll fix on some familiar general class
programs, say Python programs, but all the reasoning to follow would apply to
all other general classes of programs such as Java or C++.

A \emph{string procedure} is procedure that is applicable to data of type
\strtyp\ and returns values of type \textbf{boolean}.  When a string procedure,
$P$, applied to $s \in \strtyp$ returns \True, we'll say that $P$
\term{recognizes} $s$.

(In the text, $P$ was defined to recognize $s$ when applying it to $S$ caused a
computation that eventually \emph{halted} and values. if any, returned by the
halted computation were ignored.  We've changed that so recognition means the
positive act of returning \True.  $P$ does \emph{not} recognize $s$ when it
returns \False, or when it never returns any value---because it aborts or runs
forever.)
 
The set of strings recognized by a procedure $P$ called the \emph{language,
  $\rcg(P)$, recognized by $P$}.

A procedure declaration is a text, $s$, that conforms to the grammatical rules
for programs.  It defines a procedure $P_s$ which we can think of as the result
of compiling $s$ to an executable.  The text $s$ itself can be treated as an
object of type \strtyp.

It's convenient to have a procedure $P_s$ for every string $s$, so if $s$ is not
a grammatically well-formed procedure declaration, we just define $P_s$ to be
some default string procedure---say one that returns neither \True\ nor
\False\ on any input: it aborts or runs forever when applied to anything.  Now
every string now defines a string procedure, and every string procedure is $P_s$
for some $s \in \textbf{string}$.

We'll be interested in the set of recognizable languages, the set of languages
$L$ such that $L = \rcg(P)$ for some procedure $P$.  If we define
\[ 
\lsub{s} \eqdef \rcg{P_S},
\]
then the recognizable languages are precisely the languages $L_s$ than can be
specified by a string $s$.

The text showed that 

\bparts

\ppart Define
\[
\notself \eqdef \set{s \in \strtyp \suchthat s \notin L_s}.
\]
Prove that \notself\ is not recognizable.
\hint Same as the proof that the halting 

\begin{solution}
Since $f(s)$ is the set of strings recognized by $P_s$, everything in
$\range{f}$ is a recognizable set.  Conversely, every recognizable set
is in $\range{f}$: if $\mathcal{R}$ is a recognizable set, then by
definition, there is a procedure that recognizes $R$.  Let $r$ be the
typed input from which such a recognizer was compiled, that is,
suppose $P_r$ is the recognizer for $R$.  This means $\mathcal{R} =
f(r) \in \range{f}$.
\end{solution}

\eparts

This is exactly the set up we need to apply the reasoning behind Russell's
Paradox to define a set that is not in the range of $f$, that is, a set of
strings, $\mathcal{N}$, that is \emph{not} recognizable.

\bparts

\ppart\label{Ps-to-s}
Let
\[
\mathcal{N} \eqdef \set{s \in \textbf{string} \suchthat s \notin f(s)}.
\]

Prove that $\mathcal{N}$ is not recognizable.

\hint Similar to Russell's paradox or the proof of Theorem~\bref{powbig}.

\begin{staffnotes}
Refer students to the Russell paradox slide or the text for Theorem~\bref{powbig}.
\end{staffnotes}

\begin{solution}
By definition of $\mathcal{N}$,
\begin{equation}\label{Psnf}
s \in \mathcal{N} \qiff s \notin f(s).
\end{equation}
for every \textbf{string}, $s$.

Now assume to the contrary that $\mathcal{N}$ was recognizable by some
string procedure.  This procedure must have a string, $w$, that
describes it, so we have
\begin{align}
s \in \mathcal{N} & \qiff P_w \text{ applied to $s$ returns \True},\notag\\
                  & \qiff s \in f(w) \label{Psfw} & \text{(by def.\ of $f$)}
\end{align}
for all \textbf{string}'s $s$.

Combining~\eqref{Psnf} and ~\eqref{Psfw}, we have that for every string, $s$,
\begin{equation}\label{snfsf}
s \notin f(s) \qiff s \in f(w),
\end{equation}
for all \textbf{string}s $s$.

Now letting $s$ be $w$ in~\eqref{snfsf}, we reach the contradiction
\[
w \notin f(w) \qiff w \in f(w).
\]
This contradiction implies that the assumption that $\mathcal{N}$ was
recognizable must be false.

\end{solution}

\ppart Discuss what the conclusion of part~\eqref{Ps-to-s} implies about
the possibility of writing ``program analyzers'' that take programs
as inputs and analyze their behavior.

\begin{solution}
  Let's call a programming procedure ``unconscious'' if it does not
  return \True\ when applied to its own textual definition.

  Rephrased informally, the conclusion of part~\eqref{Ps-to-s} says
  that it is logically impossible to design a \emph{general} program
  analyzer, which takes as input the text of an arbitrary program, and
  recognizes when the program is unconscious.  This implies that it is
  impossible to write a program which does the more general analysis
  of how an arbitrary procedure behaves when applied to arbitrary
  arguments.

  By the way, it \emph{is} feasible to write a general procedure that
  recognizes the texts of ``conscious'' procedures, namely texts for
  procedures that \emph{do} return \True\ when applied to their own
  descriptions.  The ``consciousness'' recognizer simply takes an
  input text, $s$, and then simulates $P_s$ applied to $s$.  In other
  words, this general procedure just acts like a virtual machine
  simulator or ``interpreter'' for the programming language of its
  input programs.  Note that this naive procedure runs forever on all
  input programs that run forever!

  It's also important to recognize that there's no hope of getting around
  this by switching programming languages.  For example, by
  part~\eqref{Ps-to-s}, no C++ program can analyze arbitrary C++ programs,
  and no Java program can analyze Java programs, but you might wonder if a
  language like C++, which allows more intimate manipulation of computer
  memory than Java, might therefore allow a C++ program to analyze general
  Java programs.  But there is no loophole here: since it's possible to
  write a Java program that is a simulator/interpreter for C++ programs,
  if a C++ program could analyze Java programs, so could the Java program
  that simulated the C++ program, contradicting~\eqref{Ps-to-s}.
\end{solution}

\eparts

\end{problem}

\endinput
