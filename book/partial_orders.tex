\chapter{Partial Orders}\label{partial-order-chapter}

%AND EQUIVALENCE RELATIONS to be added

Partial orders are a kind of binary relation that come up a lot.  The
familiar $\leq$ order on numbers is a partial order, but so is the
containment relation on sets and the divisibility relation on
integers.

Partial orders have particular importance in computer science because they
capture key concepts used, for example, in solving task scheduling
problems, analyzing concurrency control, and proving program termination.

\section{Axioms for Partial Orders}

The prerequisite structure among MIT subjects provides a nice illustration
of partial orders.  Here is a table indicating some of the prerequisites of
subjects in the the Course 6 program of Spring '07:
\begin{center}
\begin{tabular}{|l|l|}
\hline
Direct Prerequisites & Subject\\ \hline
18.01 & 6.042\\ \hline
 18.01 & 18.02\\ \hline
 18.01 & 18.03\\ \hline
 8.01 & 8.02\\ \hline
 6.001 & 6.034\\ \hline
 6.042 & 6.046\\ \hline
 18.03, 8.02 & 6.002\\ \hline
 6.001, 6.002 & 6.004\\ \hline
 6.001, 6.002 & 6.003\\ \hline
 6.004 & 6.033\\ \hline
 6.033 & 6.857\\ \hline
 6.046 & 6.840\\ \hline
\end{tabular}
\end{center}

Since 18.01 is a direct prerequisite for 6.042, a student must take 18.01
before 6.042.  Also, 6.042 is a direct prerequisite for 6.046, so in fact,
a student has to take \emph{both} 18.01 and 6.042 before taking 6.046.  So
18.01 is also really a prerequisite for 6.046, though an implicit or
indirect one; we'll indicate this by writing
\[
18.01 \prq 6.046.
\]

This prerequisite relation has a basic property known as
\term{transitivity}: if subject $a$ is an indirect prerequisite of
subject $b$, and $b$ is an indirect prerequisite of subject $c$, then
$a$ is also an indirect prerequisite of $c$.

In this table, a longest sequence of prerequisites is
\[
18.01 \prq 18.03 \prq 6.002 \prq 6.004 \prq 6.033 \prq 6.857
\]
so a student would need at least six terms to work through this sequence
of subjects.  But it would take a lot longer to complete a Course 6 major
if the direct prerequisites led to a situation\footnote{MIT's Committee on
Curricula has the responsibility of watching out for such bugs that might
creep into departmental requirements.} where two subjects turned out to be
prerequisites of \emph{each other}!  So another crucial property of the
prerequisite relation is that if $a \prq b$, then it is not the case that
$b \prq a$.  This property is called \term{asymmetry}.

Another basic example of a partial order is the subset relation,
$\subseteq$, on sets.  In fact, we'll see that every partial order can be
represented by the subset relation.

\begin{definition}
A binary relation, $R$, on a set $A$ is:
\begin{itemize}

\item \emph{transitive} \qiff 
$[a \mrel{R}  b \text{ and } b \mrel{R}  c]\ \QIMPLIES\  a \mrel{R}  c$
\quad for every $a,b,c\in A$,

\item \emph{asymmetric} \qiff
$a \mrel{R}  b\  \QIMPLIES\  \QNOT(b \mrel{R}  a)$
\quad for all $a,b\in A$,

\item a \emph{strict partial order} iff it is transitive and asymmetric.
\end{itemize}

\end{definition}

So the prerequisite relation, $\prq$, on subjects in the MIT catalogue is
a strict partial order.  More familiar examples of strict partial orders
are the relation, $<$, on real numbers, and the proper subset relation,
$\subset$, on sets.

The subset relation, $\subseteq$, on sets and $\leq$ relation on numbers
are examples of \emph{reflexive} relations in which each element is
related to itself.  Reflexive partial orders are called \emph{weak}
partial orders.  Since asymmetry is incompatible with reflexivity, the
asymmetry property in weak partial orders is relaxed so it applies only to
two different elements.  This relaxation of the asymmetry is called
antisymmetry:

\begin{definition}
A binary relation, $R$, on a set $A$, is
\begin{itemize}

\item \emph{reflexive} \qiff $a \mrel{R}  a$ \quad for all $a \in A$,

\item \emph{antisymmetric}\label{antis} \qiff
$a \mrel{R}  b\ \QIMPLIES\ \QNOT(b \mrel{R}  a)$
\quad for all $a \neq b \in A$,

\item a \emph{weak partial order} iff it is transitive, reflexive and
antisymmetric.

\end{itemize}
\end{definition}
%
Some authors define partial orders to be what we call weak partial orders,
but we'll use the phrase ``partial order'' to mean either a weak or strict
one.

For weak partial orders in general, we often write an ordering-style
symbol like $\preceq$ or $\sqsubseteq$ instead of a letter symbol like
$R$.  (General relations are usually denoted by a letter like $R$ instead
of a cryptic squiggly symbol, so $\preceq$ is kind of like the musical
performer/composer Prince, who redefined the spelling of his name to be
his own squiggly symbol.  A few years ago he gave up and went back to the
spelling ``Prince.'')  Likewise, we generally use $\prec$ or $\sqsubset$ to
indicate a strict partial order.  \iffalse We also write $b \succeq a$ to
mean $a \preceq b$ and $b \succ a$ to mean $a \prec b$.\fi

Two more examples of partial orders are worth mentioning:

\begin{example}\label{supset}
Let $A$ be some family of sets and define $a \mrel{R} b$ iff $a
\supset b$.  Then $R$ is a strict partial order.
\end{example}

For integers, $m,n$ we write $m \divides n$ to mean that $m$
\emph{divides} $n$, namely, there is an integer, $k$, such that $n=km$.

\begin{example}\label{divides}
The divides relation is a weak partial order on the nonnegative integers.
\end{example}

\section{Representing Partial Orders by Set Containment}

Axioms can be a great way to abstract and reason about important
properties of objects, but it helps to have a clear picture of the things
that satisfy the axioms.  We'll show that every partial order can be
pictured as a collection of sets related by containment.  That is, every
partial order has the ``same shape'' as such a collection.  The technical
word for ``same shape'' is ``isomorphic.''

\begin{definition}\label{relation-isomorphism}
  A binary relation, $R$, on a set, $A$, is
  \term{isomorphic} to a relation, $S$, on a set $D$ iff there is a
  relation-preserving bijection from $A$ to $D$.  That is, there is
  bijection $f:A \to D$, such that for all $a,a' \in A$,
  \[
  a \mrel{R} a'\ \qiff\ f(a) \mrel{S} f(a').
  \]
\end{definition}

\begin{theorem}
  Every weak partial order, $\preceq$, is isomorphic to the subset
  relation, on a collection of sets.
\end{theorem}

To picture a partial order, $\preceq$, on a set, $A$, as a collection of
sets, we simply represent each element $A$ by the set of elements
that are $\preceq$ to that element, that is,
\[
a \corresp \set{b \in A \suchthat b \preceq a}.
\]
For example, if $\preceq$ is the divisibility relation on the set of
integers, $\set{1,3,4,6,8,12}$, then we represent each of these integers
by the set of integers in $A$ that divides it.  So
\begin{align*}
1 & \corresp \set{1}\\
3 & \corresp \set{1,3}\\
4 & \corresp \set{1,4}\\
6 & \corresp \set{1,3,6}\\
8 & \corresp \set{1,4,8}\\
12 & \corresp \set{1,3,4,6, 12}
\end{align*}
So, the fact that $3 \divides 12$ corresponds to the fact that $\set{1,3}
\subseteq \set{1,3,4,6, 12}$.

In this way we have completely captured the weak partial order $\preceq$ by the
subset relation on the corresponding sets.  Formally, we have
\begin{lemma}\label{rgb}
  Let $\preceq$ be a weak partial order on a set, $A$.  Then $\preceq$ is
  isomorphic to the subset relation on the collection of inverse images of
  elements $a \in A$ under the $\preceq$ relation.
\end{lemma}
We leave the proof to
Problem~\ref{PS_weak_partial_order_isomorphic_to_subset}.  Essentially
the same construction shows that strict partial orders can be
represented by set under the proper subset relation, $\subset$.

\begin{problems}
\classproblems
\pinput{CP_prerequisite_relation}
\pinput{CP_partial_order_on_power_set}

\homeworkproblems
\pinput{PS_weak_partial_order_isomorphic_to_subset}
\end{problems}


%% Total Orders %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Total Orders}

The familiar order relations on numbers have an important additional
property: given two different numbers, one will be bigger than the other.
Partial orders with this property are said to be
\emph{total}\footnote{``Total'' is an overloaded term when talking about
  partial orders: being a total order is a much stronger condition than
  being a partial order that is a total relation.  For example, any weak
  partial order such as $\subseteq$ is a total relation.} \emph{orders}.


\begin{definition}
Let $R$ be a binary relation on a set, $A$, and let $a, b$ be elements of
$A$.  Then $a$ and $b$ are \emph{comparable} with respect to $R$ iff $[a
  \mrel{R} b\ \QOR\ b \mrel{R} a]$.  A partial order for which every two
different elements are comparable is called a \emph{total order}.
\end{definition}

So $<$ and $\le$ are total orders on $\reals$.  On the other hand, the
subset relation is \emph{not} total, since, for example, any two different
finite sets of the same size will be incomparable under $\subseteq$.  The
prerequisite relation on Course 6 required subjects is also not total
because, for example, neither 8.01 nor 6.001 is a prerequisite of the
other.

\begin{problems}
\practiceproblems
\pinput{TP_basic_partial_orders}

\classproblems
\pinput{CP_divisibility_partial_order}
\pinput{CP_partially_ordered_by_divisibility}
\pinput{CP_binary_relations_on_01}
\pinput{CP_strict_PO_irreflexive}
\pinput{CP_inverse_partial_order}

\homeworkproblems
\pinput{PS_preserve_transitivity}

\examproblems
\pinput{CP_binary_relations_on_01_mq}

\end{problems}



%% Product Orders %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Product Orders}\label{prodsec}

Taking the product of two relations is a useful way to construct new
relations from old ones.

\begin{definition}\label{productrel}
\hyperdef{def}{productrel}{The product}, $R_1 \cross R_2$, of relations
$R_1$ and $R_2$ is defined to be the relation with
\begin{eqnarray*}
\domain{R_1 \cross R_2} &\eqdef& \domain{R_1} \cross \domain{R_2},\\
\codomain{R_1 \cross R_2} &\eqdef& \codomain{R_1} \cross \codomain{R_2},\\
(a_1,a_2)\, (R_1 \cross R_2)\, (b_1,b_2) &\text{iff}& [a_1\, R_1\, b_1
\text{ and } a_2\, R_2\, b_2].
\end{eqnarray*}

\end{definition}

\begin{example}\label{Y}
Define a relation, $Y$, on age-height pairs of being younger \emph{and}
shorter.  This is the relation on the set of pairs $(y,h)$ where $y$ is a
nonnegative integer $\le 2400$ which we interpret as an age in months, and $h$
is a nonnegative integer $\le 120$ describing height in inches.  We define $Y$
by the rule
\[
(y_1,h_1)\, Y\, (y_2,h_2) \qiff y_1 \le y_2\ \QAND\ h_1 \le h_2.
\]
That is, $Y$ is the product of the $\le$-relation on ages and the
$\le$-relation on heights.
\end{example}

It follows directly from the definitions that products preserve the
properties of transitivity, reflexivity, irreflexivity, and
antisymmetry, as shown in
Problem~\ref{CP_product_relation_properties}.  That is, if $R_1$ and
$R_2$ both have one of these properties, then so does $R_1 \cross
R_2$.  This implies that if $R_1$ and $R_2$ are both partial orders,
then so is $R_1 \cross R_2$.

On the other hand, the property of being a total order is not preserved.
For example, the age-height relation $Y$ is the product of two total
orders, but it is not total: the age 240 months, height 68 inches pair,
(240,68), and the pair (228,72) are incomparable under $Y$.

\begin{problems}
\classproblems
\pinput{CP_product_relation_properties}
\end{problems}

%% Scheduling %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Scheduling}

Scheduling problems are a common source of partial orders: there is a set,
$A$, of tasks and a set of constraints specifying that starting a certain
task depends on other tasks being completed beforehand.  We can picture
the constraints by drawing labelled boxes corresponding to different
tasks, with an arrow from one box to another if the first box corresponds
to a task that must be completed before starting the second one.

\begin{samepage}
\begin{example}\label{cloth}
Here is a drawing describing the order in which you could put on clothes.
The tasks are the clothes to be put on, and the arrows indicate what should be
put on directly before what.
\begin{center}\includegraphics{figures/clothes.mps}\end{center}
\end{example}
\end{samepage}

When we have a partial order of tasks to be performed, it can be useful to
have an order in which to perform all the tasks, one at a time, while
respecting the dependency constraints.  This amounts to finding a total
order that is consistent with the partial order.  This task of finding a
total ordering that is consistent with a partial order is known as
\emph{topological sorting}. \iffalse probably because the sort is based
only on the topology (shape) of the poset and not on the actual values.\fi

\begin{definition}
A \term{topological sort} of a partial order, $\prec$, on a set, $A$, is
a total ordering, $\sqsubset$, on $A$ such that
\[
a \prec b\ \QIMPLIES\  a \sqsubset b.
\]
\end{definition}

For example,
\begin{align*}
  \text{shirt} \sqsubset \text{sweater} \sqsubset \text{underwear}
  \sqsubset \text{leftsock}
  \sqsubset \text{rightsock} \sqsubset \text{pants}\\
  \sqsubset \text{leftshoe} \sqsubset \text{rightshoe} \sqsubset
  \text{belt} \sqsubset \text{jacket},
\end{align*}
is one topological sort of the partial order of dressing tasks given by
Example~\ref{cloth}; there are several other possible sorts as well.

Topological sorts for partial orders on finite sets are easy to construct
by starting from \term{minimal} elements:

\begin{definition}
  Let $\preceq$ be a partial order on a set, $A$.  An element $a_0 \in A$
  is \index{minimum}\term*{minim\underline{um}} iff it is $\preceq$ every
  other element of $A$, that is, $a_0 \preceq b$ for all $b \neq a_0$.

  The element $a_0$ is \index{minimal}\term*{minim\underline{al}} iff no
  other element is $\preceq a_0$, that is, $\QNOT(b \preceq a_0)$ for all
  $b \neq a_0$.
\end{definition}
There are corresponding definitions for \term{maximum} and \term{maximal}.
Alternatively, a maximum(al) element for a relation, $R$, could be
defined to be as a minimum(al) element for $\inv{R}$.

In a total order, minimum and minimal elements are the same thing.  But a
partial order may have no minimum element but lots of minimal elements.
There are four minimal elements in the clothes example: leftsock,
rightsock, underwear, and shirt.

To construct a total ordering for getting dressed, we pick one of these
minimal elements, say shirt.  Next we pick a minimal element among the
remaining ones.  For example, once we have removed shirt, sweater becomes
minimal.  We continue in this way removing successive minimal elements
until all elements have been picked.  The sequence of elements in the
order they were picked will be a topological sort.  This is how the
topological sort above for getting dressed was constructed.

\iffalse %pedantic about the obvious

For this method of topological sorting to work, we need to be sure there
is always a minimal element.  This is sort of obvious, but noting that an
infinite partially ordered set might have no minimal element ---consider
$<$ on the $\integers$ ---we should  would be prudent to prove that minimal
elements exist.

\begin{lemma}\label{finmin}
  \hyperdef{rule}{mine1}{Every} partial order on a nonempty finite set has
  a minimal element.

\begin{proof} Let $R$ be a strict partial order on a set, $A$.  Define the \emph{weight}
of an element $a \in A$ to be $\card{R\set{a}}$ ---the number of elements
in the set $R\set{a}$.  Since $A$ is finite, the weights of all elements
in $A$ are nonnegative integers, so there must be an $a_0 \in A$ with the
smallest weight.

Now suppose $\card{R\set{a_0}} \neq 0$.  Then there is an element $a_1 \in
R\set{a_0}$, which implies (by transitivity of $R$) that $R\set{a_1}
\subseteq R\set{a_0}$, and hence $\card{R\set{a_1}} \leq
\card{R\set{a_0}}$.  But since $R$ is strict, $a_1 \in R\set{a_0} -
R\set{a_1}$, so in fact $\card{R\set{a_1}} < \card{R\set{a_0}}$,
contradicting the fact the $a_0$ has the smallest weight.

This contradiction implies that $\card{R\set{a_0}} = 0$, which means that
no element is related by $R$ to $a_0$, that is, $a_0$ is minimal.

A similar argument works in the case that $R$ is a weak partial order.

\end{proof}
\end{lemma}
\fi

So our construction shows:

\begin{theorem}\label{thm:topological}
Every partial order on a finite set has a topological sort.
\end{theorem}

There are many other ways of constructing topological sorts.  For example,
instead of starting ``from the bottom'' with minimal elements, we could
build a total starting \emph{anywhere} and simply keep putting additional
elements into the total order wherever they will fit.  In fact, the domain
of the partial order need not even be finite: we won't prove it, but \emph{all}
partial orders, even infinite ones, have topological sorts.

\subsection{Parallel Task Scheduling}

For a partial order of task dependencies, topological sorting provides a
way to execute tasks one after another while respecting the dependencies.
But what if we have the ability to execute more than one task at the same
time?  For example, say tasks are programs, the partial order indicates
data dependence, and we have a parallel machine with lots of processors
instead of a sequential machine with only one.  How should we schedule the
tasks?  Our goal should be to minimize the total \emph{time} to complete
all the tasks.  For simplicity, let's say all the tasks take the same
amount of time and all the processors are identical.

So, given a finite partially ordered set of tasks, how long does it take
to do them all, in an optimal parallel schedule?  We can also use partial
order concepts to analyze this problem.

In the clothes example, we could do all the minimal elements first
(leftsock, rightsock, underwear, shirt), remove them and repeat.  We'd need
lots of hands, or maybe dressing servants.  We can do pants and sweater
next, and then leftshoe, rightshoe, and belt, and finally jacket.

In general, a \emph{schedule} for performing tasks specifies which
tasks to do at successive steps.  Every task, $a$, has be scheduled at
some step, and all the tasks that have to be completed before task $a$
must be scheduled for an earlier step.

\begin{definition}\label{def:schedule}
A \term{parallel schedule} for a strict partial order, $\prec$, on a set,
$A$, is a partition\footnote{Partitioning a set,
$A$, means ``cutting it up'' into non-overlapping, nonempty pieces.  The
pieces are called the blocks of the partition.  More precisely, a
\emph{partition} of $A$ is a set $\mathcal{B}$ whose elements are nonempty
subsets of $A$ such that
\begin{itemize}
\item if $B,B' \in \mathcal{B}$ are different sets, then $B \intersect B' =
 \emptyset$, and
\item $\lgunion_{B\in \mathcal{B}} B = A$.
\end{itemize}} of $A$ into sets $A_0, A_1,\dots,$ such
that for all $a,b \in A$, $k \in \naturals$,
\[
[a \in A_k \QAND b \prec a] \quad\QIMPLIES\quad b \in A_j \text{ for some } j < k.
\]
The set $A_k$ is called the set of
elements \term{scheduled at step $k$}, and the \emph{length} of the
schedule is the number of sets $A_k$ in the partition.  The maximum
number of elements scheduled at any step is called the \term{number of
  processors} required by the schedule.
\end{definition}

So the schedule we chose above for clothes has four steps
\begin{align*}
A_0 = & \set{\text{leftsock, rightsock, underwear, shirt}},\\
A_1 = & \set{\text{pants, sweater}},\\
A_2 = & \set{\text{leftshoe, rightshoe, belt}},\\
A_3 = & \set{\text{jacket}}.
\end{align*}
and requires four processors (to complete the first step).

Notice that the dependencies constrain the tasks underwear, pants,
belt, and jacket to be done in sequence.  This implies
that at least four steps are needed in \emph{every} schedule for
getting dressed, since if we used fewer than four steps, two of these
tasks would have to be scheduled at the same time.  A set of tasks
that must be done in sequence like this is called a \emph{chain}.

\begin{definition}
A \term{chain} in a partial order is a set of elements such that any
two different elements in the set are comparable.  A chain is said to
\index{end of chain}\emph{end at} an its maximum element.
\end{definition}

In general, the earliest step at which an element $a$ can ever be
scheduled must be at least as large as any chain that ends at $a$.  A
\emph{largest} chain ending at $a$ is called a \term{critical path} to
$a$, and the size of the critical path is called the \term{depth} of
$a$.  So in any possible parallel schedule, it takes at least
$\dpth{a}$ steps to complete task $a$.

There is a very simple schedule that completes every task in this
minimum number of steps.  Just use a ``greedy'' strategy of performing
tasks as soon as possible.  Namely, schedule all the elements of depth
$k$ at step $k$.  That's how we found the schedule for getting dressed
given above.

\iffalse

 For getting dressed, here is a picture of the
schedule obtained in this way:

\begin{center}\includegraphics{figures/clothesparallel.mps}\end{center}
\fi

\begin{theorem}\label{thm:parallel-time}
Let $\prec$ be a strict partial order on a set, $A$.  A minimum length
schedule for $\prec$ consists of the sets $A_0, A_1,\dots,$
where
\[
A_k \eqdef \set{a \suchthat \dpth{a} =k}.
\]
\end{theorem}

We'll leave to Problem~\ref{PS_antichains_by_depth} the proof that the
sets $A_k$ are a parallel schedule according to
Definition~\ref{def:schedule}.

The minimum number of steps needed to schedule a partial order,
$\prec$, is called the \term{parallel time} required by $\prec$, and a
largest possible chain in $\prec$ is called a \term{critical path} for
$\prec$.  So we can summarize the story above by this way: with an
unlimited number of processors, the minimum parallel time to complete
all tasks is simply the size of a critical path:

\begin{corollary}\label{cor:critical-path-time}
Parallel time = length of critical path.
\end{corollary}

\section{Dilworth's Lemma}

\begin{definition}
An \term{antichain} in a partial order is a set of elements such that any
two elements in the set are incomparable.
\end{definition}

Our conclusions about scheduling also tell us something about antichains.

\begin{corollary}\label{cor:parallel}
If the largest chain in a partial order on a set, $A$, is of size $t$,
then $A$ can be partitioned into $t$ antichains.
\end{corollary}

\begin{proof}
Let the antichains be the sets $A_k \eqdef \set{a \suchthat \dpth{a}
  =k}$.
It is an easy exercise to verify that each $A_k$ is an antichain
(Problem~\ref{PS_antichains_by_depth})
\end{proof}

Corollary~\ref{cor:parallel} implies a famous
result\footnote{Lemma~\ref{lem:Dilworth} also follows from a more
  general result known as Dilworth's Theorem which we will not
  discuss.} about partially ordered sets:

\begin{lemma}[Dilworth]\label{lem:Dilworth}
\hyperdef{rule}{Dilworth}{For} all $t>0$, every partially ordered set with
$n$ elements must have either a chain of size greater than $t$ or an
antichain of size at least $n / t$.
\end{lemma}

\begin{proof}
Assume there is no chain of size greater than $t$, that is, the largest
chain is of size $\le t$.  Then by Corollary~\ref{cor:parallel}, the $n$
elements can be partitioned into at most $t$ antichains.  Let $\ell$ be
the size of the largest antichain.  Since every element belongs to exactly
one antichain, and there are at most $t$ antichains, there can't be more
than $\ell t$ elements, namely, $\ell t \geq n$.  So there is an antichain
with at least $\ell \geq n / t$ elements.
\end{proof}

\begin{corollary}\label{cor:Dilworth}
Every partially ordered set with $n$ elements has a chain of size greater
than $\sqrt{n}$ or an antichain of size at least $\sqrt{n}$.

\begin{proof}
  Set $t = \sqrt{n}$ in Lemma~\ref{lem:Dilworth}.
\end{proof}
\end{corollary}

\begin{example}
In the dressing partially ordered set, $n = 10$.

Try $t = 3$.  There is a chain of size $4$.

Try $t = 4$.  There is no chain of size $5$, but there is an antichain of
size $4 \geq 10 / 4$.
\end{example}

\begin{example}
Suppose we have a class of 101 students.  Then using the product partial
order, $Y$, from Example~\ref{Y}, we can apply Dilworth's Lemma to
conclude that there is a chain of 11 students who get taller as they get
older, or an antichain of 11 students who get taller as they get younger,
which makes for an amusing in-class demo.
\end{example}

%% Scheduling Problems %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problems}
\practiceproblems
\pinput{TP_biggest_chain_antichain}
\pinput{TP_subsequence_of_101}
%\examproblems
\pinput{MQ_multi_schedule_tasks}

\classproblems
\pinput{CP_class_scheduling}
\pinput{CP_conquering_the_galaxy}
\pinput{CP_minimal_maximal_elements}

\homeworkproblems
\pinput{PS_antichains_by_depth}
\pinput{PS_subsequences_partial_order_Dilworth_Lemma}
\pinput{PS_Brents_theorem}
\end{problems}

\endinput
